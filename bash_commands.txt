=======================================
echo Siemka
=======================================

=======================================
read name
echo $name
=======================================

=======================================
who > file (nadpisuje cały plik)
cat /etc/passwd >> file (dopisuje na końcu pliku)
=======================================

=======================================
who | wc -l
who | wc -l > usercount
=======================================

=======================================
askname < myname (zawartość pliku myname jest pobierana przez skrypt jako argument)
=======================================

=======================================
ls -a > filelist 2> errors (2> is errors output. here - to errors file)
cat errors
=======================================

=======================================
commands may be run asynchronously (in the background) by using &
conky &
leafpad &
=======================================

=======================================
Special characters:
The fee is $10 - bad
The fee is \$10 - good 
"The fee is $10" - good  
'The fee is $10' - good 
=======================================

=======================================
Executing the script:
1) ./script
2) sh script (no need to be made executable)
3) . script (run by current shell)
=======================================

=======================================
in VIM
1) :!./script (run script in vim while editing)
2) :!chmod +x % (% means current file)
3) :!% (runs current script)
=======================================

=======================================
on the first line of script: script interpreter - what shell for this script
for example:
#!/bin/zsh 
or #!/bin/sh
or #!/usr/local/bin/perl etc.
=======================================

=======================================
CGI program - program that is used to provide interactibity, automotion or database connectivity to a web site

A CGI program can be any type of program, including Bourne shell scripts

For a Bourne shell script to act as a CGI script, it must have the following attributes:

1) must be executable
2) must begin with the line #!/bin/sh
3) standard output begin with a line such as the following:
	Content-type: text/html
=======================================

=======================================
All shell variables are strings.
a=10 (assign - without spaces)
street="Street Avenue" (quotation marks if space in the middle)
$ - retrieves the content

The variable is not visible to other programs unless the variable has been  added to the environment
e.g.
month=January
export month

'xyz' - Single quotes remove all of the shell's special-character features.
e.g. 

"xyz" - Double quotes - some characters are still treated as special.
e.g. echo "$LOGNAME made $1000"

`xyz` - Text enclosed in back quotes is treated as a UNIX command and is executed in its own shell. They have nothing to do with special characters.
e.g. list=`who | sort`
	echo $list

merge commands in ( ) e.g.
(echo "the date is `date`") > output_file
or
(
pwd
ls
)

Run two or more commands in one line with ;
echo Enter your name:; read name

echo This command is split \
with this
or
cd ~/tmp && \
git clone ..........
=======================================

=======================================
When every UNIX command completes, it invisibly returns a value:
0 - program completed with no errors
others - some error has occured

The exit status is stored in the built-in variable called "?".
echo $?
=======================================

=======================================
command1 && command2
command2 will only run if command1 completes with an exit status of 0 (all is OK)
command1 || command2
command 2 will only run if command1 completes with an exit status that is not 0 (sth is bad)
=======================================

=======================================
if diff file1 file2 > /dev/null
then
	echo The files are the same
	rm file2
	exit
fi
=======================================

=======================================
if command1
then
	one set of commands
else
	another set of commands
fi
=======================================

=======================================
if ls file1 > /dev/null
then
	: # ":" is the "do nothing" command
else 
	echo The file does not exist
	exit
fi
=======================================

=======================================
elif -> else if

if command1
then
	command set 1
elif command2
then
	command set 2
else
	command set 3
fi
=======================================
"test" was designed for use with "if" statement
e.g.
if test $var1 -gt $max
then
	echo That value is too large
fi

You must have spaces around both sides of the "="
e.g.
test $var1 = 20


test value1 value2
	returns true (0) if the values are equal
test value1 != value2
	return true (0) if the values are different
test value1 -gt value2
	return true (0) if the values are both integer values and values1 is greater than value2
			-lt (less than_
			-ge (greater than or equal to)
			-le (less than or equal to)
test value 
	returns true (0) if the value is non-empty
test -z value
	returns true (0) if the value is empty (zero-length)

test -f filename
	returns true (0) if the given file exists and is a regular file (not directory, device etc)
test -d filename
	returns true (0) if the given file exists and is a directory
test -s filename
	returns true (0) if the given file exists and has a file-size greater than 0
test -r|w|x filename
	returns true (0) if the given file exists and is readable | writable | executable by the current process

e.g.
if [ -z "$name" ]
then
	echo You did not enter a filename
fi
=======================================

=======================================
case $var1 in
	val1)
		code for case 1
		;;
	val2)
		code for case 2
		;;
	val3)
		code for case 3
		;;
	val4|val5|val5)
		code for cases 4-6
		;;
	d*)
		code for anything that starts with d
		;;
	[bB]eatles}"The Beatles")
		code for beatles, Beatles of The Beatles
		;;
	*)
		# "default"
		;;
esac
=======================================

=======================================
The given code block will be repeatedly executed until the given command returns an exit status that is non-zero

while command
do
	code block
done

e.g.
read answer
while [ "$answer" != chickens ]
do
	echo That answer is incorrect
	echo Please try again
	read answer
done
=======================================

=======================================
# Break and Continue
Break statement will cause the loop to immediately terminate.
Goes to the next line after done.

The continue statement will cause the loop to abandon the current iteration.
=======================================

=======================================
# expr - for numerical calculations
expr 3 + 2 (spaces around all of arguments!)

e.g.
a=15
b=3
c=`expr $a / $b`
echo $c

e.g.
read count
i = 1
while [ $i -le $count ]
do
	echo This is loop $i of $count
	i=`expr $i + 1`
done
=======================================

=======================================
# for loop

for var1 in Bread Meat Dairy Vegetables Fruit
do
	echo One of the main food groups is $var1
done

# This loop copies all non-empty txt files to backups dir
for fname in *.txt
do
	[ -s $fname ] && cp $fname backups
done
=======================================
